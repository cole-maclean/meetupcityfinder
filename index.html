<!DOCTYPE html>
<meta charset="utf-8">
<style>

.water {
  fill: #00248F;
}

.land {
  fill: #A98B6F;
  stroke: #FFF;
  stroke-width: 0.7px;
}

.stroke {
  fill: none;
  stroke: #000;
  stroke-width: 3px;
}

.fill {
  fill: #00248F;
}

.graticule {
  fill: none;
  stroke: #777;
  stroke-width: .5px;
  stroke-opacity: .5;
}

.boundary {
  fill: none;
  stroke: #fff;
  stroke-width: .5px;
}

.overlay {
  fill: none;
  pointer-events: all;
}

.svg-container {
    display: inline-block;
    position: relative;
    width: 100%;
    padding-bottom: 100%; /* aspect ratio */
    vertical-align: top;
    overflow: hidden;
}
.svg-content-responsive {
    display: inline-block;
    position: absolute;
    left: 0;
}

ul > li {
    display: inline-block;
    padding: 10px 40px;
    /* You can also add some margins here to make it look prettier */
    zoom:1;
    *display:inline;
    /* this fix is needed for IE7- */
    border: 1px solid black;

}

input[type=text]
{
    border:solid 1px #BFBDBD;
    height: 28px;
    padding-left:10px;
    width: 191px;
    box-shadow: 2px 2px 0 #828181 inset;
}
</style>
<body>

<form name="topic-list" onSubmit="return handleTopicAdd()">
  <input type="text" id="topic-list-input" placeholder="Add a topic...">
</form>

Click List Item to Remove:

<ul id="topic-list"></ul>
<script src="https://d3js.org/d3.v3.min.js"></script>
<script src="https://d3js.org/topojson.v1.min.js"></script>
<script src="d3.geo.zoom.js"></script>
<script src="colorbrewer.js"></script>

<script>

var width = 1350,
    height = 630,
    globe_height = 600,
    globe_width = 680;

var projection = d3.geo.orthographic()
    .scale(270)
    .translate([globe_width / 2, globe_height / 2])
    .clipAngle(90)
    .precision(.1)

svg = d3.select("body")
   .append("div")
   .classed("svg-container", true) //container class to make it responsive
   .append("svg")
   //responsive SVG needs these 2 attributes and no width and height attr
   .attr("preserveAspectRatio", "xMinYMin meet")
   .attr("viewBox", "0 0 1350 630")
   //class to make it responsive
   .classed("svg-content-responsive", true)

var legend = svg.append("g")
              .attr("height",500)
              .attr("width",55)
              .attr("transform", "translate(50,40) rotate(90)");

svg.append("text")
          .text("Lowest Rank")
          .attr("y",25)

svg.append("text")
          .text("Highest Rank")
          .attr("y",500+40+15)

var colorScale = d3.scale.quantize()
    .range(colorbrewer.YlGn[8])

var top_ten_colorScale = d3.scale.quantize()
    .range(colorbrewer.YlGn[8])
    .domain([10,0])

//Append a defs (for definition) element to your SVG
var defs = legend.append("defs");

//Append a linearGradient element to the defs and give it a unique id
var linearGradient = defs.append("linearGradient")
    .attr("id", "linear-gradient");

//Horizontal gradient
linearGradient
    .attr("x1", "0%")
    .attr("y1", "0%")
    .attr("x2", "100%")
    .attr("y2", "0%");

linearGradient.selectAll("stop") 
    .data( colorScale.range() )                  
    .enter().append("stop")
    .attr("offset", function(d,i) { return i/(colorScale.range().length-1); })
    .attr("stop-color", function(d) { return d; });

legend.append("rect")
  .attr("width", 500)
  .attr("height", 20)
  .style("fill", "url(#linear-gradient)");

var globe_svg = svg.append("svg")
    .attr("width", globe_width)
    .attr("height", globe_height)
    .attr("x",90)
    .style("pointer-events","none");

var top_ten_rect = svg.append("rect")
                 .attr("width",200)
                 .attr("height",200)
                 .attr("transform", "translate(900,35)")
                 .style("fill", "#A98B6F")

var top_ten_text = svg.append("g")
                      .attr("width",200)
                      .attr("height",200)
                      .attr("transform", "translate(900,30)")


top_ten_text.append("text")
            .text("Top 10 Cities")
            .style("font-weight","bold")

var zoom = d3.behavior.zoom()
        .scaleExtent([1,6])
        .on("zoom",zoomed);

var zoomEnhanced = d3.geo.zoom().projection(projection)
        .on("zoom",zoomedEnhanced);

var drag = d3.behavior.drag()
          .origin(function() { var r = projection.rotate(); return {x: r[0], y: -r[1]}; })
          .on("drag", dragged)
          .on("dragstart", dragstarted)
          .on("dragend", dragended)

var path = d3.geo.path()
    .projection(projection)
    .pointRadius(function(d) { return d.radius; });

var graticule = d3.geo.graticule();

var pathG = globe_svg.append("g")
                    .attr("width", globe_width)
                    .attr("height", globe_height)
                    .attr("transform", "translate(0,30)")
                    .attr("class","overlay")
                    .call(zoomEnhanced)

pathG.append("defs").append("path")
    .datum({type: "Sphere"})
    .attr("id", "sphere")
    .attr("d", path);

pathG.append("use")
    .attr("class", "stroke")
    .attr("xlink:href", "#sphere");

pathG.append("use")
    .attr("class", "fill")
    .attr("xlink:href", "#sphere");

pathG.append("path")
    .datum(graticule)
    .attr("class", "graticule")
    .attr("d", path);

var topic_list = [];

function handleTopicAdd(event){
    console.log(document.getElementById("topic-list-input").value)
    add_topic(document.getElementById("topic-list-input").value.toLowerCase())
    return false;
}

function handleDetailsClick(city){
  city_topic_members = {};
  detail_data = [];

  loaded_topic_data.forEach(function(d) { //loaded topic data is pre-sorted so resulting object also sorted largest to smallest membership
    if (d.city === city){
        city_topic_members[d.topic] = d.members
      }
  });
  rank_order = []; for(var key in city_topic_members) rank_order.push(key);
  rank_order.sort(function(a,b){
    normalizer = 1000000
    a = (loaded_topic_members[a].indexOf(city_topic_members[a])) - city_topic_members[a]/normalizer
    b = (loaded_topic_members[b].indexOf(city_topic_members[b])) - city_topic_members[b]/normalizer

    return (a-b)
  })
  top_three = rank_order.slice(0,3);

  top_three.forEach(function(d){
      rank = loaded_topic_members[d].indexOf(city_topic_members[d])
      detail_data.push({"topic":d,"rank":rank,"percentile":(1-rank/loaded_topic_members[d].length),"members":city_topic_members[d]})
  });

  for(var key in city_topic_members) {
    if (topic_list.indexOf(key) != -1){
      rank = loaded_topic_members[key].indexOf(city_topic_members[key])
      detail_data.push({"topic":key,"rank":rank,"percentile":(1-rank/loaded_topic_members[key].length),"members":city_topic_members[key]})
    }
  }

  svg.selectAll(".detail").remove();
  var detail_plot = svg.append("g")
                       .attr("width",300)
                       .attr("height",500)
                       .attr("transform", "translate(800,280)")
                       .selectAll(".detail")
                       .data(detail_data).enter()

  detail_plot.append("text")
             .text(city)
             .attr("class","detail")
             .style("font-weight","bold")

  detail_plot.append("text")
             .attr("height",25)
             .attr("y",function(d,i){return (i+1)*30})
             .text(function(d){
                    //trim the string to the maximum length
                    topic_string = d.topic + " "
                    var trimmedTopic = topic_string.substr(0,75);
                    //re-trim if we are in the middle of a word
                    trimmedTopic = trimmedTopic.substr(0, Math.min(trimmedTopic.length, trimmedTopic.lastIndexOf(" ")))
                    return trimmedTopic
                  })
             .attr("class","detail")
             .attr("dominant-baseline", "central")

  var rect_width = 200
  detail_plot.append("rect")
           .attr("fill","none")
           .attr("width",rect_width)
           .attr("height",25)
           .style("stroke","black")
           .attr("y",function(d,i){return (i+1)*30})
           .attr("x",200)
           .attr("class","detail")
           .attr("transform", "translate(0,-10)")

  detail_plot.append("rect")
         .attr("fill",function(d){return colorScale(d.rank)})
         .attr("width",function(d){return rect_width*d.percentile})
         .attr("height",25)
         .attr("y",function(d,i){return (i+1)*30})
         .attr("x",200)
         .attr("class","detail")
         .attr("transform", "translate(0,-10)")

format = d3.format("0,000");

 detail_plot.append("text")
             .attr("height",25)
             .attr("y",function(d,i){return (i+1)*30})
             .text(function(d){return format(d.members) + " members " + "#" + (d.rank+1)})
             .attr("class","detail")
             .attr("dominant-baseline", "central")
             .attr("x",410)
}

function add_topic(val){
    d3.select("body").select("#topic-list").append("li");
    topic_list.push(val);
    var p = d3.select("body").selectAll("li")
    .data(topic_list)
    .text(function(d){return d;})
    .style("background-color", "#cccccc")
    .style("color","#222222;")
    .on({
          "mouseover": function(d) {
            d3.select(this).style("cursor", "pointer")
          },
          "mouseout": function(d) {
            d3.select(this).style("cursor", "default")
          },
          "click": function(d) {
            d3.select(this).remove();
            indx = topic_list.indexOf(d);
            topic_list.splice(indx, 1);
            update(loaded_topic_data);
          }
        });

    update(loaded_topic_data)
}

var loaded_topic_data;
var loaded_topic_members = {};

d3.json("grouped_topic_data.json",function(topic_data) {
  loaded_topic_data = topic_data;
  loaded_topic_data.forEach(function(d){ //loaded topic data is pre-sorted so resulting object also sorted largest to smallest membership
    if (d.topic in loaded_topic_members){
      loaded_topic_members[d.topic].push(d.members)
    }
    else {
      loaded_topic_members[d.topic] = [d.members]
    }
  });
  update(loaded_topic_data);
});


function update(topic_data){
    var cities = {};
    pathG.selectAll("path.point").remove();
    var city_points = pathG.selectAll("path.point")
                        .data(topic_data.filter(function(d){
                         if (topic_list.indexOf(d.topic) != -1) {
                              if (d.city in cities) {
                                cities[d.city] = [cities[d.city][0] + d.members,d.lat,d.lon]
                              }
                              else {
                                cities[d.city] = [d.members,d.lat,d.lon]
                              }
                          return d;
                         }
                       }))
                        .enter().append("g")
                            .on({
                                "mouseover": function(d) {
                                  d3.select(this).style("cursor", "pointer")
                                },
                                "mouseout": function(d) {
                                  d3.select(this).style("cursor", "default")
                                },
                                "click": function(d) {
                                  handleDetailsClick(d.city)
                                }
                              });


    ordered_cities = []; for(var key in cities) ordered_cities.push(key);
    ordered_cities.sort(function(b,a){return cities[a][0]-cities[b][0]});

    colorScale.domain([ordered_cities.length,0])

    city_points.append("path")
      .style("fill",function(d){return colorScale(ordered_cities.indexOf(d.city))})
      .datum(function(d) {
         return {type: "Point", coordinates: [d.lon, d.lat], radius: 5};
      })
      .attr("class", "point")
      .attr("d", path)   

    var members = Object.keys(cities).map(function(key){
      return cities[key][0];
    });

    top_ten_list = ordered_cities.slice(0,10)
    d3.selectAll(".top-ten").remove();
    top_ten_text.selectAll("top-ten")
           .data(top_ten_list).enter()
           .append("text")
           .attr("class","top-ten")
           .attr("y",function(d,i){return (i+1)*20})
           .text(function(d,i){return (i+1) + ". " + d})
           .style("fill",function(d,i){return top_ten_colorScale(i)})
            .on({
                  "mouseover": function(d) {
                    d3.select(this).style("cursor", "pointer")
                  },
                  "mouseout": function(d) {
                    d3.select(this).style("cursor", "default")
                  },
                  "click": function(d) {
                            handleDetailsClick(d)           
                  }
                });  
}


d3.json("worldTopo.json", function(error, world) {
  // to render meridians/graticules on top of lands, use insert which adds new path before graticule in the selection
  pathG.insert("path", ".graticule")
      .datum(topojson.feature(world, world.objects.land))
      .attr("class", "land")
      .attr("d", path)

  pathG.insert("path", ".graticule")
      .datum(topojson.mesh(world, world.objects.countries, function(a, b) {return a !== b; }))
      .attr("class", "boundary")
      .attr("d", path);
});

// apply transformations to map and all elements on it 
  function zoomed()
  {
    pathG.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
    //grids.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
    //geofeatures.select("path.graticule").style("stroke-width", 0.5 / d3.event.scale);
    pathG.selectAll("path.boundary").style("stroke-width", 0.5 / d3.event.scale);
  }

  function zoomedEnhanced()
  {
    pathG.selectAll("path").attr("d",path);
  }

  function dragstarted(d) 
  {

    //stopPropagation prevents dragging to "bubble up" which triggers same event for all elements below this object
    d3.event.sourceEvent.stopPropagation();
    d3.select(this).classed("dragging", true);
  }

  function dragged(d) {
          projection.rotate([d3.event.x, -d3.event.y]);
          pathG.selectAll("path").attr("d", path);
  }

  function dragended(d) 
  {
    d3.select(this).classed("dragging", false);
  }

d3.select(self.frameElement).style("height", globe_height + "px");

</script>