<!DOCTYPE html>
<meta charset="utf-8">
<style>

.water {
  fill: #00248F;
}

.land {
  fill: #A98B6F;
  stroke: #FFF;
  stroke-width: 0.7px;
}

.stroke {
  fill: none;
  stroke: #000;
  stroke-width: 3px;
}

.fill {
  fill: #00248F;
}

.graticule {
  fill: none;
  stroke: #777;
  stroke-width: .5px;
  stroke-opacity: .5;
}

.boundary {
  fill: none;
  stroke: #fff;
  stroke-width: .5px;
}

.overlay {
  fill: none;
  pointer-events: all;
}

ul > li {
    display: inline-block;
    padding: 10px 40px;
    /* You can also add some margins here to make it look prettier */
    zoom:1;
    *display:inline;
    /* this fix is needed for IE7- */

}

input[type=text]
{
    border:solid 1px #BFBDBD;
    height: 28px;
    padding-left:10px;
    width: 191px;
    box-shadow: 2px 2px 0 #828181 inset;
}
</style>
<body>

<form name="topic-list" onSubmit="return handleTopicAdd()">
  <input type="text" id="topic-list-input" placeholder="Add a topic...">
</form>

Click List Item to Remove:

<ul id="topic-list"></ul>
<script src="http://d3js.org/d3.v3.min.js"></script>
<script src="http://d3js.org/topojson.v1.min.js"></script>
<script src="d3.geo.zoom.js"></script>
<script src="colorbrewer.js"></script>

<script>

var width = 1300,
    height = 680,
    globe_height = 650,
    globe_width = 680;

var projection = d3.geo.orthographic()
    .scale(270)
    .translate([globe_width / 2, globe_height / 2])
    .clipAngle(90)
    .precision(.1)

svg = d3.select("body").append("svg")
        .attr("height",height)
        .attr("width",width)

var legend = svg.append("g")
              .attr("height",500)
              .attr("width",55)
              .attr("transform", "translate(50,-100) rotate(90)");

legend.append("text")
          .text("Lowest Rank")
          .attr("transform", "translate(0,15)");

legend.append("text")
          .text("Highest Rank")
          .attr("transform", "translate(0,415)");

var colorScale = d3.scale.quantize()
    .range(colorbrewer.YlGn[8])

//Append a defs (for definition) element to your SVG
var defs = legend.append("defs");

//Append a linearGradient element to the defs and give it a unique id
var linearGradient = defs.append("linearGradient")
    .attr("id", "linear-gradient");

//Horizontal gradient
linearGradient
    .attr("x1", "0%")
    .attr("y1", "0%")
    .attr("x2", "100%")
    .attr("y2", "0%");

linearGradient.selectAll("stop") 
    .data( colorScale.range() )                  
    .enter().append("stop")
    .attr("offset", function(d,i) { return i/(colorScale.range().length-1); })
    .attr("stop-color", function(d) { return d; });

legend.append("rect")
  .attr("width", 500)
  .attr("height", 20)
  .style("fill", "url(#linear-gradient)");

var globe_svg = svg.append("svg")
    .attr("width", globe_width)
    .attr("height", globe_height)
    .attr("x",55)

d3.select("body").append("ul").append("li").text("test")

var zoom = d3.behavior.zoom()
        .scaleExtent([1,6])
        .on("zoom",zoomed);

var zoomEnhanced = d3.geo.zoom().projection(projection)
        .on("zoom",zoomedEnhanced);

var drag = d3.behavior.drag()
          .origin(function() { var r = projection.rotate(); return {x: r[0], y: -r[1]}; })
          .on("drag", dragged)
          .on("dragstart", dragstarted)
          .on("dragend", dragended);

var path = d3.geo.path()
    .projection(projection)
    .pointRadius(function(d) { return d.radius; });

var graticule = d3.geo.graticule();

var pathG = globe_svg.append("g");

globe_svg.append("rect")
        .attr("class", "overlay")
        .attr("width", globe_width)
        .attr("height", globe_height)
        .attr("transform", "translate(0,30)")
        .call(zoomEnhanced)

pathG.append("defs").append("path")
    .datum({type: "Sphere"})
    .attr("id", "sphere")
    .attr("d", path);

pathG.append("use")
    .attr("class", "stroke")
    .attr("xlink:href", "#sphere");

pathG.append("use")
    .attr("class", "fill")
    .attr("xlink:href", "#sphere");

pathG.append("path")
    .datum(graticule)
    .attr("class", "graticule")
    .attr("d", path);

var topic_list = [];

function handleTopicAdd(event){
    console.log(document.getElementById("topic-list-input").value)
    add_topic(document.getElementById("topic-list-input").value)
    return false;
}

function add_topic(val){
    d3.select("body").select("#topic-list").append("li");
    topic_list.push(val);
    var p = d3.select("body").selectAll("li")
    .data(topic_list)
    .text(function(d){return d;})
    .style("background-color", "#cccccc")
    .style("color","#222222;")
    .on('click',function(d){
        d3.select(this).remove();
        indx = topic_list.indexOf(d);
        topic_list.splice(indx, 1);
        update_city_points(loaded_topic_data);
    });

    update_city_points(loaded_topic_data)
}

var loaded_topic_data;

d3.json("grouped_topic_data.json",function(topic_data) {
  loaded_topic_data = topic_data;
  update_city_points(loaded_topic_data);
});


function update_city_points(topic_data){
    var cities = {};
    pathG.selectAll("path.point").remove();
    var city_points = pathG.selectAll("path.point")
                        .data(topic_data.filter(function(d){
                         if (topic_list.indexOf(d.topic) != -1) {
                              if (d.city in cities) {
                                cities[d.city] = cities[d.city] + d.members
                              }
                              else {
                                cities[d.city] = d.members
                              }
                          return d;
                         }
                       }));
    ordered_cities = []; for(var key in cities) ordered_cities.push(key);
    ordered_cities.sort(function(a,b){return cities[a]-cities[b]});

    colorScale.domain([0,ordered_cities.length])

    city_points.enter().append("path")
      .attr("fill",function(d){return colorScale(ordered_cities.indexOf(d.city))})
      .datum(function(d) {
         return {type: "Point", coordinates: [d.lon, d.lat], radius: 5};
      })
      .attr("class", "point")
      .attr("d", path)

    var members = Object.keys(cities).map(function(key){
      return cities[key];
    });
}


d3.json("worldTopo.json", function(error, world) {
  // to render meridians/graticules on top of lands, use insert which adds new path before graticule in the selection
  pathG.insert("path", ".graticule")
      .datum(topojson.feature(world, world.objects.land))
      .attr("class", "land")
      .attr("d", path)

  pathG.insert("path", ".graticule")
      .datum(topojson.mesh(world, world.objects.countries, function(a, b) { return a !== b; }))
      .attr("class", "boundary")
      .attr("d", path);
});

// apply transformations to map and all elements on it 
  function zoomed()
  {
    pathG.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
    //grids.attr("transform", "translate(" + d3.event.translate + ")scale(" + d3.event.scale + ")");
    //geofeatures.select("path.graticule").style("stroke-width", 0.5 / d3.event.scale);
    pathG.selectAll("path.boundary").style("stroke-width", 0.5 / d3.event.scale);
  }

  function zoomedEnhanced()
  {
    pathG.selectAll("path").attr("d",path);
  }

  function dragstarted(d) 
  {
    //stopPropagation prevents dragging to "bubble up" which triggers same event for all elements below this object
    d3.event.sourceEvent.stopPropagation();
    d3.select(this).classed("dragging", true);
  }

  function dragged() {
          projection.rotate([d3.event.x, -d3.event.y]);
          pathG.selectAll("path").attr("d", path);
  }

  function dragended(d) 
  {
    d3.select(this).classed("dragging", false);
  }

d3.select(self.frameElement).style("height", globe_height + "px");

</script>